前情回顾

1. http协议

    http请求 :
        请求行 : GET　 HTTP/1.1
        请求头 :
        空行
        请求体

    http响应 :
        请求行 : HTTP/1.1  200 OK
        请求头 : Content-Type:text/html
        空行
        请求体 : 数据内容

2. 进程

    多任务编程: 一个程序中编写多个任务,多个任务可以同时执行

    进程概念 :  什么是进程   PCB   时间片   进程状态   进程产生过程
               父子进程   孤儿进程   僵尸进程

    <编译原理>   <算法导论>   <计算机网络>   <操作系统原理>
    公众号 :  CSDN    python程序员    python开发者
    APP : 知乎  掘金

3. fork 实现多进程

4. getpid()   getppid()   exit()   _exit()

5. 僵尸进程处理方法
    wait()
    signal()


考虑问题时 : 效率,,复杂度,,难易程度




群聊聊天室
【1】 有人进入聊天室需要输入姓名,姓名不能重复
【2】 有人进入聊天室时,其他人会收到通知:xxx 进入了聊天室
【3】 一个人发消息,其他人会收到:xxx : xxxxxxxxxxx
【4】 有人退出聊天室,则其他人也会收到通知:xxx退出了聊天室
【5】 扩展功能:服务器可以向所有用户发送公告:管理员消息: xxxxxxxxx

思路分析 :

1. 需求分析 : 干什么,,达到什么效果

2. 技术点确定

    * 数据如何发生
      转发: 客户端发出-->服务器-->转发给其他用户

    * 网络模型如何构建
       UDP 网络模型
      群聊模式使用UDP居多
      点对点聊天使用 TCP

    * 用户信息如何维护
       服务端保存用户信息: 什么地方使用,,需要什么特征,,存什么
       特征: 可变,用户进入聊天室就要将用户信息保存,当用户退出时,就要删除用户信息
       可用列表,字典,链表保存用户信息(用户名,地址),
       列表 : [(name,address),]
       字典 : {name:address}
       链表 : class Node:
                def __init__(self,name,address)
                    pass

    * 聊天室的随意收发怎么处理
        多进程分别进行收发操作

3. 结构设计

    封装设计: 函数式编程

    功能模块划分:
            网络结构搭建
            进入聊天室
            聊天
            退出聊天室
            管理员消息

4. 每个功能客户端和服务端分别做什么

    * 网络功能搭建

        服务端: 完成udp通信
        客户端: 完成udp通信

    * 进入聊天室

        客户端:  * 输入姓名
                * 给服务器发送请求
                * 接受反馈情况
                * 如果不允许进入则重复输入姓名

        服务端:  * 接受请求
                * 判断用户名是否存在
                * 反馈结果
                * 如果允许进入,保存用户信息,通知其他人

    * 聊天

        客户端:  * 创建新进程
                * 一个进程收消息
                * 一个进程发消息

        服务端:  * 接收消息,判断消息请求
                * 将消息转发给其他人

    * 退出

        客户端:  * 输入 quit 或者 X 表示退出
                * 发送请求给服务器
                * 结束进程

        服务端:  * 接受请求 判断请求类型
                * 删除用户
                * 将退出信息告知其他人

5. 通信协议
    登录: L name     OK   表示可以登录
    聊天: C name    xxxxxxxxxxxxxx
    退出: Q name


















  *****  multiprocessing 模块创建进程  *****

  进程创建方法  (跨平台性较好)


1. 流程特点

【1】 将需要子进程执行的事件封装为函数
【2】 通过模块的Process类创建进程对象,关联函数
【3】 可以通过进程对象设置进程信息及属性
【4】 通过进程对象调用start启动进程
【5】 通过进程对象调用join回收进程



2. 基本接口使用

Process()
功能 : 创建进程对象
参数 : target 绑定要执行的目标函数
args 元组,用于给target函数位置传参
kwargs 字典,给target函数键值传参

p.start()
功能 : 启动进程
注意:启动进程此时target绑定函数开始执行,该函数作为子进程执行内容,此时进程真正被创建

p.join([timeout])
功能:阻塞等待回收进程
参数:超时时间

注意
    1. 使用multiprocessing创建进程同样是子进程复制父进程空间代码段,父子进程运行互不影响
    2. 子进程只运行target绑定的函数部分,其余内容均是父进程执行内容
    3. multiprocessing中父进程往往只用来创建子进程回收子进程,具体事件由子进程完成
    4. multiprocessing创建的子进程中无法使用标准输入(input)



3. 进程对象属性

p.name 进程名称(默认名称:Process-1)

p.pid 对应子进程的PID号

p.is_alive() 查看子进程是否在生命周期

p.daemon 设置父子进程的退出关系
如果设置为True则子进程会随父进程的退出而结束
要求必须在start()前设置
如果daemon设置成True 通常就不会使用 join()






















